### start() 方法  
调用线程的start() 方法，只是请求虚拟机运行相应的线程，而线程何时运行由线程调度器决定  
### 创建线程的两种方法  
创建线程的两种主要方式如下：   
```
        //法儿1
        Thread threada = new ThreadA();
        threada.start();
        //法儿2
        Thread threadb = new Thread(new Taskx());
        threadb.start();
```
一种是继承 Thread 类，重写run() 方法  
另一种是实现Runnable接口，然后将实现Runnable的类实例传入Thread  
完整代码看[这里](https://github.com/jasondong-1/java/tree/master/concurrent)  
下面我们看一下Thread 的run方法,其中target就是我们传入的Runnable，如果传入了Runnable  
则调用Runnable 的run方法，如果我们用的法儿1 来创建线程就会调用我们重写的方法  
```
    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
```
> Thread 的start() 方法不可重复调用,否则会导致线程状态异常  

### ThreadGroup  
顾名思义，可以将多个thread添加到一个group内，同意管理  
直接看[例子](https://github.com/jasondong-1/java/blob/master/concurrent/src/main/java/com/jason/example/ThreadGroupExample.java)  

### join yield sleep  
join:当一个线程（a）在执行过程当中调用了另一个线程(b)的join方法，则 a会等b执行结束后才继续执行  
yield：当一个线程调用自己的yield方法时，就回通知线程调度器自己不是很着急，可以先调度其他任务，但是  
自己不一定马上就会停止  
sleep： 当前线程暂停一段时间  

### 线程的状态  
new:当线程刚刚创建时处于此状态  
Runnable：此状态下包含两种状态    
* ready 处于此状态的线程可以被线程调度器调度，当调用yield 方法时，线程状态可能会由running 转换未ready    
* running 运行状态  
blocked：比如申请一个其他线程已经占有的锁时，当前线程会处于阻塞状态  
waiting：当调用Object.wait() 或 Thread.join() 方法时线程会处于此状态   
timed-wating：类似wait，但是会等待制定的时间，如果超过了时间，线程会回到Runnable状态  
terminated：线程执行结束，包括由于异常结束时会处于此状态  

### 线程的监视  
一般情况下使用的两个工具查看某一时刻线程的状态  
1. jstack  
> jstack -l pid

需要先找到相关程序的pid  

2. 使用可视化工具  
jvisualvm，这是jdk自带的工具  

### 多线程的优缺点  
优点：  
* 提高系统响应性（比如加载音乐和打开app界面），吞吐率  
* 充分利用计算机多核资源  
* 减少系统资源消耗，躲开进程比在一个进程中使用多线程使用资源更多    
缺点:  
* 对于共享数据，容易造成线程安全问题  
* 线程活性问题  
 如果锁使用不当，容易造成死锁  
 可能出现线程饥饿的情况，某些线程一直处于ready状态  
* 上下文切换，造成了额外的消耗  

### 串行，并发，并行  
假设我们要泡茶，分如下三部：  
1.烧开水  
2.洗茶具，泡茶  
串行：一个人做，先烧水，水烧开后洗茶具泡茶  
并发：一个人做，先烧水，烧水过程中洗茶具，水开后泡茶  
并行：两个人做，一个人烧水，一个人洗茶具，水开后泡茶  

一个处理器可以实现并发，多个处理器可以实现并行  

###  竞态产生的两个情形  
竞态：多线程对共享变量的交错操作  
1.read --> modify --> write  
2.check-->then-->act  

### 线程安全问题表现在如下三个方面  
* 原子性  
  * 一个操作不能中途而废，要么全部执行成功，要么回到初始状态，不能只执行一半，比如：
  ```
  public void setConnInfo（String host, int port）{
   this.host = host;
   this.port = port;
  }

  ```
  上面的设置链接信息方法，要么host，port都设置为新值，要么保留未原来的值  
  * 两个原子性操作不能交错，不能在只设置了host时就去读取链接信息  
  
> 1.原子操作是针对共享变量的，局部变量可以被认为都具有原子性  
> 2.只有在多线程环境下谈原子性才有意义   
  
  如何解决原子性问题？ 使用锁
  java 中long，double是64位的，当使用32位虚拟机执行他们的写操作时是不能保证原子性的，因此一个  
  线程在修改long，double时，另一个线程可能镀组到中间结果，  
  volatile关键字可以保证java变量写操作的原子性，仅仅是写操作，不包括read-modify-write等操作  
  java中对任何变量的读操作都是原子性的  
  
  
* 可见性  
 一个线程对共享变量的值做了更改，但是其他线程却没有看到，这就是可见性问题。课件性问题的成因一般有两个：  
 1.编译器对代码做了优化，修改了代码  
 2.被修改的值没有被更新到高速缓存或者主内存中，只是保留在了缓存器中  
 
 解决方法：给变量加volatile关键字，该关键字可以规避如上两个问题，还可以保持写操作的原子性  
 
 
 
* 有序性  
源代码顺序-->编译，动态编译后的程序顺序-> 处理器上实际执行的顺序-->其他处理器锁感知到的当前处理器的感知顺序  

### 内部锁&外部锁  
内部锁：通过synchronize 关键字实现的  
外部锁： 通过lock类实现的  

### 锁
锁可以使临界区代码满足原子性，可见性，有序性，从而保证了线程的安全性  
可见性：当获取锁的时候度鲜橙会将共享变量的最新值读到自己处理器的高速缓存中，当释放锁的时候写线程把共享变量的最新  
值推送到自己处理器的高速缓存中，这样度鲜橙就可以读到共享变量的最新值  

使用锁保证线程安全性必须满足如下两个条件：  
* 访问共享变量的线程必须使用同一个锁  
* 访问共享变量的线程即使是只读取而不更新共享变量，也要获取对应的锁  



  