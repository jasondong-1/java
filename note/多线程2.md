### 正确的单例模式  
1. 单线程下的单利模式  
```java
/**
 * 单线程模式下的单利模式
 */
public class SingleThreadSingleton {
    private static SingleThreadSingleton instance;

    private SingleThreadSingleton() {
    }

    public static SingleThreadSingleton getInstance() {
        if (instance == null) {
            instance = new SingleThreadSingleton();
        }
        return instance;
    }
}
```

2.多线程下的单例模式  
2.1 正确的单利模式  
```java
/**
 * 这里演示的是一个线程安全的单例模式
 */
public class MultithreadingSingleton {
    private static MultithreadingSingleton instance = null;

    private MultithreadingSingleton() {

    }

    public static MultithreadingSingleton getInstance() {
        synchronized (MultithreadingSingleton.class) {
            if (instance == null) {
                instance = new MultithreadingSingleton();
            }
            return instance;
        }
    }

}
```
虽说上面的代码是线程安全的，但是没事获取实例的时候都要加锁，多少开销有点儿大，于是乎有了如下的版本2.2  

2.2不安全的单例模式  
```java
/**
 * 不安全
 */
class MultithreadingSingletonV2 {
    private static MultithreadingSingletonV2 instance = null;

    private MultithreadingSingletonV2() {

    }

    public static MultithreadingSingletonV2 getInstance() {
        if (instance == null) {  //1.
            synchronized (MultithreadingSingleton.class) {
                if (instance == null) {//2.
                    instance = new MultithreadingSingletonV2();
                }
            }
        }
        return instance;

    }

}
```  
我们之前说过，锁保证线程安全的前提是，不管读还是写共享变量都要加锁， 而操作1在读取共享变量缺没有加锁，所以会造成线程安全问题  
原因如下：  
instance = new MultithreadingSingletonV2();可以分解为如下三个步骤：  
1.给MultithreadingSingletonV2() 分配存储空间  
2.初始化MultithreadingSingletonV2()  
3.将MultithreadingSingletonV2()的对象地址赋值给instance    

但是编译后可能发生如下重排序：1 - 3 - 2  

所以当步骤1 读到instance不为null时，MultithreadingSingletonV2() 可能并未初始化完毕  
解决办法：给instance 变量加volatile 修饰，防止instance = new MultithreadingSingletonV2() 重排序  

### CAS  
compare and swap 比较再进行赋值，请看伪代码：  
```
public boolean cas（int oldval ,int newval, Object var）{//var 是共享变量  
 if(var.get==oldvar){
   var.set(newval)
   return true
 }
 return false
}
```
一般情况下cas与循环一起使用来更新值：  
```
int oldval;
int newval;
do{
 oldval = var.get
 newval = oldval+1
}while(!cas(oldval,newval,var))
```

cas 操作只能保障更新操作的原子性,不保障可见性  

### 原子变量类  
AtomicLong AtomicInteger 等，实现原理 cas + volatile  
**提供使用sample**  

### static 和 final 在多线程中的应用  
|  | static | final |
| --- | --- | --- |
| 有序性 | 保障 | 保障 |
| 可见性 | 保障 | 不保障 |  
static：第一次读取到变量时可以保障可见性   

 
### 多线程可以提高多少速率  
$$ S_{max}=\frac{1}{p+\frac{1-p}{N}} $$ 
其中p是必须同步的处理流程所消耗的时间比例，N是并发数，可以看到当核数趋于无穷大的时候，多线程的速率其实和必须同步的  
时间有关，所以得优化算法来把串行事件缩短  

### 多线程设置多少个并发数  
1.cpu密集型：设置N+1 个，因为cpu密集型任务可能由于缺页中断而被切出等问题，为避免cpu浪费，多设置一个  
2.io密集型：可能导致上下文切换，如果一个线程可以满足性能要求则设置一个即可，如果一个不能满足需求，则设置  
2N个，因为io密集型任务在等待返回时是不占用cpu资源的  

3.在实际的开发当中，当前任务可能是cpu密集+io密集型的，那么我们课程采用如下公式计算  
$$ N_{thread} = N_{cpu} * U_{cpu} * (1+\frac{WT}{ST})$$  

其中 N<sub>thread</sub> 代表最终设置的线程数  
N<sub>cpu</sub>代表机器的核数  
U<sub>cpu</sub> 表示当前进程战友的资源比例（人为规定的）  
WT代表程序的等待时间（我理解未等待io返回等不占用cpu的时间）  
ST service time 占用cpu的时间  
wt st 可以用我们之前介绍的jvisualvm工具来查看  

### wait/notify  
在多线程中，一个线程执行目标操作前需要满足一定条件就需要用到wait/notify  
[请看例子](https://github.com/jasondong-1/java/blob/master/concurrent/src/main/java/com/jason/example/WaitNotifyTest.java)  
 
1.一个线程只有在持有一个对象内部锁的情况下才可以调用其 wait() 方法  
2.可能有多个线程同事执行了一个对象的wait 方法  
3.当调用一个对象的wait方法进入等待时，wait方法所属对象的内部锁会被释放，其他锁不会被释放  
4.一个线程只有在持有一个对象内部锁的情况下才能调用其notify 方法  
5.调用notify方法后，会随机唤醒一个等待线程，等待线程会重新去申请锁执行剩余的代码，但是notify方法不会释放锁  
所以最好将notify方法放在临界区代码最后一行  
6.notify只会唤醒一个等待线程， notifyAll 会唤醒所有等待线程  
7.object.wait(long),无返回值，无法判断一个线程的唤醒是由于超时还是notify了  

过早唤醒： 多个线程对多个保护条件的等待都调用了同一个对象的wait方法，那么人一个条件满足的时候调用notifyAll方法，则  
所有的线程都会唤醒，包括那些条件未满足的线程，这就是过早唤醒  

### THread.join  
底层调用了wait/notify方法  

### Condition接口  
Condition 接口提供了类似 Object.wait/notify 的方法，请看[例子](https://github.com/jasondong-1/java/blob/master/concurrent/src/main/java/com/jason/example/ConditionTest.java)  
Condition 是绑定在Lock上的，当调用await方法时，会释放对应的锁，当await的线程获得锁后会继续执行await的剩余部分  
因为一个Lock可以new 出多个Condition，所以可以用不同conditon来保护保护条件，解决过早唤醒的问题  

### CountDownLatch  
满足一定条件才执行，除了可以用Condition接口还可以用CountDownLatch，看[例子](https://github.com/jasondong-1/java/blob/master/concurrent/src/main/java/com/jason/example/CountDownLatchTest.java)  
与condition不同CountDownLatch 的使用不需要用到锁  

> 1.countdown 内部计数器达到0之后，就会恒定为0，即便操作countdown方法也不会变为-1，所以此时调用await方法不会被暂停  
> 2.为了避免线程永远被暂停，countDown方法应该放在总是可以被执行的地方，比如finally中  

下面我们用countdown来模拟战士打靶，一组n个战士，n个靶子，n个战士全部到达靶子前方，n个战士子弹全上膛后，同时射击  
请看[例子](https://github.com/jasondong-1/java/blob/master/concurrent/src/main/java/com/jason/example/CountDownShoot.java)  

### CyclicBarrier  
CountDownLAtch 只能使用一次，如果有n排战士，每排m个战士，每排战士都到达靶子前方才可射击，所有战士射击完毕  
才可撤离，第一排打完，第二排上，循环往复，直到训练时间到，这样该如何呢，这是就需要用到CyclicBarrier，每个  
战士到达靶子前方会调用 await 等待，直到最后一个战士就绪，最后一个战士到达的时候也调用了await，但是不会等待，  
而是唤醒所有等待线程，异同往下执行，而且CyclicBarrier是可以重复使用的，  
CyclicBarrier 有两个构造方法：
>1.CyclicBarrier(int parties, Runnable barrierAction)  
2.CyclicBarrier(int parties)  
  
第一个构造方法中的Runnable ,会被最后一个等待线程执行，执行过之后，所有等待线程才会被唤醒    
请看士兵射击的[例子](https://github.com/jasondong-1/java/blob/master/concurrent/src/main/java/com/jason/example/cyclicbarrier)

CyclicBarrier使用场景  
1.迭代算法的并发化  
2.高并发测试，保证所有线程同事访问  


### 生产者-消费者模式  
生产者，消费者之间需要用到一个缓存产品的管道——阻塞队列（线程安全的）  
这里我们主要讲三个阻塞队列：ArrayBlockingQueue,LinkedBlockingQueue,SynchronousQueue  
BlockingQueue 用到的几个主要方法如下：  
```
//向queue中添加元素，如果队列满了则会等待直到可以添加元素
void put(E e) throws InterruptedException;
//向queue中添加元素，如果队列满了则会等待指定时间，添加成功返回true，不成功返回false
boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException;

//取出元素，当队列为空时则会等待，直到队列中被添加了元素
E take() throws InterruptedException;
//取出元素，当队列为空时则会等待指定时间，成功取出则返回 E，否则返回null 
E poll(long timeout, TimeUnit unit) throws InterruptedException;
```

按照存储空间是否受限来划分,可以将阻塞队列划分为有界队列和无界队列，有界队列大小由用户指定，无界队列大小一般是int的最大值。  

当生产者的速率大于消费者的速率时，产品会在队列中积压，系统消耗的内存及其他资源会增多，因此可以使用有界队列，当队列满时，让生产线程暂停。  

我们来简单看下ArrayBlockingQueue,LinkedBlockingQueue的put,take方法

  
ArrayBlockingQueue
```
    public void put(E e) throws InterruptedException {
        checkNotNull(e);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == items.length)
                notFull.await();
            enqueue(e);
        } finally {
            lock.unlock();
        }
    }
    
        public E take() throws InterruptedException {
            final ReentrantLock lock = this.lock;
            lock.lockInterruptibly();
            try {
                while (count == 0)
                    notEmpty.await();
                return dequeue();
            } finally {
                lock.unlock();
            }
        }
```
LinkedBlockingQueue  
```
    public void put(E e) throws InterruptedException {
        if (e == null) throw new NullPointerException();
        // Note: convention in all put/take/etc is to preset local var
        // holding count negative to indicate failure unless set.
        int c = -1;
        Node<E> node = new Node<E>(e);
        final ReentrantLock putLock = this.putLock;
        final AtomicInteger count = this.count;
        putLock.lockInterruptibly();
        try {
            /*
             * Note that count is used in wait guard even though it is
             * not protected by lock. This works because count can
             * only decrease at this point (all other puts are shut
             * out by lock), and we (or some other waiting put) are
             * signalled if it ever changes from capacity. Similarly
             * for all other uses of count in other wait guards.
             */
            while (count.get() == capacity) {
                notFull.await();
            }
            enqueue(node);
            c = count.getAndIncrement();
            if (c + 1 < capacity)
                notFull.signal();
        } finally {
            putLock.unlock();
        }
        if (c == 0)
            signalNotEmpty();
    }
    
        public E take() throws InterruptedException {
            E x;
            int c = -1;
            final AtomicInteger count = this.count;
            final ReentrantLock takeLock = this.takeLock;
            takeLock.lockInterruptibly();
            try {
                while (count.get() == 0) {
                    notEmpty.await();
                }
                x = dequeue();
                c = count.getAndDecrement();
                if (c > 1)
                    notEmpty.signal();
            } finally {
                takeLock.unlock();
            }
            if (c == capacity)
                signalNotFull();
            return x;
        }
```
ArrayBlockingQueue的put take方法用的是同一个锁,LinkedBlockingQueue 的put take方法用的是不同的锁，可以降低锁的争用性    

SynchronousQueue与上述两个queue略有不同，当执行SynchronousQueue.put(e)时，如果maybe线程执行SynchronousQueue.take(),put线程会暂停，  
take的时候也一样，如果没有线程put，take线程暂停  

>ArrayBlockingQueue的put 生产消费线程并发量低时使用  
LinkedBlockingQueue 生产消费线程并发量高时使用  
SynchronousQueue 消费者线程和生产者线程处理能力相当时使用  

### semaphore  
如果使用了无界队列，当生产者的生产能力大于消费者消费能力，那么队列中就可能堆积很多的产品，从而增加了资源消耗，为何限制生产者向队列中添加元素，引入了  
semaphore，semaphore可以控制同时put的数量，就像火车站进站口每次只放行几个人，从而控制了安检的流量，具体使用请看[例子](https://github.com/jasondong-1/java/blob/master/concurrent/src/main/java/com/jason/example/SemaphoreTest.java)

### 线程间直接输入与输出  
直接输入输出即不必借助中间方式，如文件，数据库等中间介质。这时要用到PipedInputstream 和 PipedOutPutStream；请看[例子](https://github.com/jasondong-1/java/blob/master/concurrent/src/main/java/com/jason/example/PipeInOut.java)  
>1.PipedInputstream 和 PipedOutPutStream适合在两个线程间使用，因为往往需要保证字节流的顺序性，如果线程过多还要维护字节顺序性，增加了程序复杂性  
2.异常问题，如果out线程抛出了异常，in线程可能永远等待下去，最好在catch块中关闭out来知会in线程  







  
 
