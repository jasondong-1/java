<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [正确的单例模式](#%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F)
- [CAS](#cas)
- [原子变量类](#%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E7%B1%BB)
- [static 和 final 在多线程中的应用](#static-%E5%92%8C-final-%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8)
- [多线程可以提高多少速率](#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E6%8F%90%E9%AB%98%E5%A4%9A%E5%B0%91%E9%80%9F%E7%8E%87)
- [多线程设置多少个并发数](#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E7%BD%AE%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%B9%B6%E5%8F%91%E6%95%B0)
- [wait/notify](#waitnotify)
- [THread.join](#threadjoin)
- [Condition接口](#condition%E6%8E%A5%E5%8F%A3)
- [CountDownLatch](#countdownlatch)
- [CyclicBarrier](#cyclicbarrier)
- [生产者-消费者模式](#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F)
- [semaphore](#semaphore)
- [线程间直接输入与输出](#%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA)
- [Thread interrupt](#thread-interrupt)
- [优雅停止线程](#%E4%BC%98%E9%9B%85%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B)
- [装饰器模式（Decorator） 同步集合](#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8Fdecorator-%E5%90%8C%E6%AD%A5%E9%9B%86%E5%90%88)
- [并发集合](#%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88)
- [线程活性故障](#%E7%BA%BF%E7%A8%8B%E6%B4%BB%E6%80%A7%E6%95%85%E9%9A%9C)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

### 正确的单例模式  
1. 单线程下的单利模式  
```java
/**
 * 单线程模式下的单利模式
 */
public class SingleThreadSingleton {
    private static SingleThreadSingleton instance;

    private SingleThreadSingleton() {
    }

    public static SingleThreadSingleton getInstance() {
        if (instance == null) {
            instance = new SingleThreadSingleton();
        }
        return instance;
    }
}
```

2.多线程下的单例模式  
2.1 正确的单利模式  
```java
/**
 * 这里演示的是一个线程安全的单例模式
 */
public class MultithreadingSingleton {
    private static MultithreadingSingleton instance = null;

    private MultithreadingSingleton() {

    }

    public static MultithreadingSingleton getInstance() {
        synchronized (MultithreadingSingleton.class) {
            if (instance == null) {
                instance = new MultithreadingSingleton();
            }
            return instance;
        }
    }

}
```
虽说上面的代码是线程安全的，但是没事获取实例的时候都要加锁，多少开销有点儿大，于是乎有了如下的版本2.2  

2.2不安全的单例模式  
```java
/**
 * 不安全
 */
class MultithreadingSingletonV2 {
    private static MultithreadingSingletonV2 instance = null;

    private MultithreadingSingletonV2() {

    }

    public static MultithreadingSingletonV2 getInstance() {
        if (instance == null) {  //1.
            synchronized (MultithreadingSingleton.class) {
                if (instance == null) {//2.
                    instance = new MultithreadingSingletonV2();
                }
            }
        }
        return instance;

    }

}
```  
我们之前说过，锁保证线程安全的前提是，不管读还是写共享变量都要加锁， 而操作1在读取共享变量缺没有加锁，所以会造成线程安全问题  
原因如下：  
instance = new MultithreadingSingletonV2();可以分解为如下三个步骤：  
1.给MultithreadingSingletonV2() 分配存储空间  
2.初始化MultithreadingSingletonV2()  
3.将MultithreadingSingletonV2()的对象地址赋值给instance    

但是编译后可能发生如下重排序：1 - 3 - 2  

所以当步骤1 读到instance不为null时，MultithreadingSingletonV2() 可能并未初始化完毕  
解决办法：给instance 变量加volatile 修饰，防止instance = new MultithreadingSingletonV2() 重排序  

### CAS  
compare and swap 比较再进行赋值，请看伪代码：  
```
public boolean cas（int oldval ,int newval, Object var）{//var 是共享变量  
 if(var.get==oldvar){
   var.set(newval)
   return true
 }
 return false
}
```
一般情况下cas与循环一起使用来更新值：  
```
int oldval;
int newval;
do{
 oldval = var.get
 newval = oldval+1
}while(!cas(oldval,newval,var))
```

cas 操作只能保障更新操作的原子性,不保障可见性  

### 原子变量类  
AtomicLong AtomicInteger 等，实现原理 cas + volatile  
**提供使用sample**  

### static 和 final 在多线程中的应用  
|  | static | final |
| --- | --- | --- |
| 有序性 | 保障 | 保障 |
| 可见性 | 保障 | 不保障 |  
static：第一次读取到变量时可以保障可见性   

 
### 多线程可以提高多少速率  
$$ S_{max}=\frac{1}{p+\frac{1-p}{N}} $$ 
其中p是必须同步的处理流程所消耗的时间比例，N是并发数，可以看到当核数趋于无穷大的时候，多线程的速率其实和必须同步的  
时间有关，所以得优化算法来把串行事件缩短  

### 多线程设置多少个并发数  
1.cpu密集型：设置N+1 个，因为cpu密集型任务可能由于缺页中断而被切出等问题，为避免cpu浪费，多设置一个  
2.io密集型：可能导致上下文切换，如果一个线程可以满足性能要求则设置一个即可，如果一个不能满足需求，则设置  
2N个，因为io密集型任务在等待返回时是不占用cpu资源的  

3.在实际的开发当中，当前任务可能是cpu密集+io密集型的，那么我们课程采用如下公式计算  
$$ N_{thread} = N_{cpu} * U_{cpu} * (1+\frac{WT}{ST})$$  

其中 N<sub>thread</sub> 代表最终设置的线程数  
N<sub>cpu</sub>代表机器的核数  
U<sub>cpu</sub> 表示当前进程战友的资源比例（人为规定的）  
WT代表程序的等待时间（我理解未等待io返回等不占用cpu的时间）  
ST service time 占用cpu的时间  
wt st 可以用我们之前介绍的jvisualvm工具来查看  

### wait/notify  
在多线程中，一个线程执行目标操作前需要满足一定条件就需要用到wait/notify  
[请看例子](https://github.com/jasondong-1/java/blob/master/concurrent/src/main/java/com/jason/example/WaitNotifyTest.java)  
 
1.一个线程只有在持有一个对象内部锁的情况下才可以调用其 wait() 方法  
2.可能有多个线程同事执行了一个对象的wait 方法  
3.当调用一个对象的wait方法进入等待时，wait方法所属对象的内部锁会被释放，其他锁不会被释放  
4.一个线程只有在持有一个对象内部锁的情况下才能调用其notify 方法  
5.调用notify方法后，会随机唤醒一个等待线程，等待线程会重新去申请锁执行剩余的代码，但是notify方法不会释放锁  
所以最好将notify方法放在临界区代码最后一行  
6.notify只会唤醒一个等待线程， notifyAll 会唤醒所有等待线程  
7.object.wait(long),无返回值，无法判断一个线程的唤醒是由于超时还是notify了  

过早唤醒： 多个线程对多个保护条件的等待都调用了同一个对象的wait方法，那么人一个条件满足的时候调用notifyAll方法，则  
所有的线程都会唤醒，包括那些条件未满足的线程，这就是过早唤醒  

### THread.join  
底层调用了wait/notify方法  

### Condition接口  
Condition 接口提供了类似 Object.wait/notify 的方法，请看[例子](https://github.com/jasondong-1/java/blob/master/concurrent/src/main/java/com/jason/example/ConditionTest.java)  
Condition 是绑定在Lock上的，当调用await方法时，会释放对应的锁，当await的线程获得锁后会继续执行await的剩余部分  
因为一个Lock可以new 出多个Condition，所以可以用不同conditon来保护保护条件，解决过早唤醒的问题  

### CountDownLatch  
满足一定条件才执行，除了可以用Condition接口还可以用CountDownLatch，看[例子](https://github.com/jasondong-1/java/blob/master/concurrent/src/main/java/com/jason/example/CountDownLatchTest.java)  
与condition不同CountDownLatch 的使用不需要用到锁  

> 1.countdown 内部计数器达到0之后，就会恒定为0，即便操作countdown方法也不会变为-1，所以此时调用await方法不会被暂停  
> 2.为了避免线程永远被暂停，countDown方法应该放在总是可以被执行的地方，比如finally中  

下面我们用countdown来模拟战士打靶，一组n个战士，n个靶子，n个战士全部到达靶子前方，n个战士子弹全上膛后，同时射击  
请看[例子](https://github.com/jasondong-1/java/blob/master/concurrent/src/main/java/com/jason/example/CountDownShoot.java)  

### CyclicBarrier  
CountDownLAtch 只能使用一次，如果有n排战士，每排m个战士，每排战士都到达靶子前方才可射击，所有战士射击完毕  
才可撤离，第一排打完，第二排上，循环往复，直到训练时间到，这样该如何呢，这是就需要用到CyclicBarrier，每个  
战士到达靶子前方会调用 await 等待，直到最后一个战士就绪，最后一个战士到达的时候也调用了await，但是不会等待，  
而是唤醒所有等待线程，异同往下执行，而且CyclicBarrier是可以重复使用的，  
CyclicBarrier 有两个构造方法：
>1.CyclicBarrier(int parties, Runnable barrierAction)  
2.CyclicBarrier(int parties)  
  
第一个构造方法中的Runnable ,会被最后一个等待线程执行，执行过之后，所有等待线程才会被唤醒    
请看士兵射击的[例子](https://github.com/jasondong-1/java/blob/master/concurrent/src/main/java/com/jason/example/cyclicbarrier)

CyclicBarrier使用场景  
1.迭代算法的并发化  
2.高并发测试，保证所有线程同事访问  


### 生产者-消费者模式  
生产者，消费者之间需要用到一个缓存产品的管道——阻塞队列（线程安全的）  
这里我们主要讲三个阻塞队列：ArrayBlockingQueue,LinkedBlockingQueue,SynchronousQueue  
BlockingQueue 用到的几个主要方法如下：  
```
//向queue中添加元素，如果队列满了则会等待直到可以添加元素
void put(E e) throws InterruptedException;
//向queue中添加元素，如果队列满了则会等待指定时间，添加成功返回true，不成功返回false
boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException;

//取出元素，当队列为空时则会等待，直到队列中被添加了元素
E take() throws InterruptedException;
//取出元素，当队列为空时则会等待指定时间，成功取出则返回 E，否则返回null 
E poll(long timeout, TimeUnit unit) throws InterruptedException;
```

按照存储空间是否受限来划分,可以将阻塞队列划分为有界队列和无界队列，有界队列大小由用户指定，无界队列大小一般是int的最大值。  

当生产者的速率大于消费者的速率时，产品会在队列中积压，系统消耗的内存及其他资源会增多，因此可以使用有界队列，当队列满时，让生产线程暂停。  

我们来简单看下ArrayBlockingQueue,LinkedBlockingQueue的put,take方法

  
ArrayBlockingQueue
```
    public void put(E e) throws InterruptedException {
        checkNotNull(e);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == items.length)
                notFull.await();
            enqueue(e);
        } finally {
            lock.unlock();
        }
    }
    
        public E take() throws InterruptedException {
            final ReentrantLock lock = this.lock;
            lock.lockInterruptibly();
            try {
                while (count == 0)
                    notEmpty.await();
                return dequeue();
            } finally {
                lock.unlock();
            }
        }
```
LinkedBlockingQueue  
```
    public void put(E e) throws InterruptedException {
        if (e == null) throw new NullPointerException();
        // Note: convention in all put/take/etc is to preset local var
        // holding count negative to indicate failure unless set.
        int c = -1;
        Node<E> node = new Node<E>(e);
        final ReentrantLock putLock = this.putLock;
        final AtomicInteger count = this.count;
        putLock.lockInterruptibly();
        try {
            /*
             * Note that count is used in wait guard even though it is
             * not protected by lock. This works because count can
             * only decrease at this point (all other puts are shut
             * out by lock), and we (or some other waiting put) are
             * signalled if it ever changes from capacity. Similarly
             * for all other uses of count in other wait guards.
             */
            while (count.get() == capacity) {
                notFull.await();
            }
            enqueue(node);
            c = count.getAndIncrement();
            if (c + 1 < capacity)
                notFull.signal();
        } finally {
            putLock.unlock();
        }
        if (c == 0)
            signalNotEmpty();
    }
    
        public E take() throws InterruptedException {
            E x;
            int c = -1;
            final AtomicInteger count = this.count;
            final ReentrantLock takeLock = this.takeLock;
            takeLock.lockInterruptibly();
            try {
                while (count.get() == 0) {
                    notEmpty.await();
                }
                x = dequeue();
                c = count.getAndDecrement();
                if (c > 1)
                    notEmpty.signal();
            } finally {
                takeLock.unlock();
            }
            if (c == capacity)
                signalNotFull();
            return x;
        }
```
ArrayBlockingQueue的put take方法用的是同一个锁,LinkedBlockingQueue 的put take方法用的是不同的锁，可以降低锁的争用性    

SynchronousQueue与上述两个queue略有不同，当执行SynchronousQueue.put(e)时，如果maybe线程执行SynchronousQueue.take(),put线程会暂停，  
take的时候也一样，如果没有线程put，take线程暂停  

>ArrayBlockingQueue的put 生产消费线程并发量低时使用  
LinkedBlockingQueue 生产消费线程并发量高时使用  
SynchronousQueue 消费者线程和生产者线程处理能力相当时使用  

### semaphore  
如果使用了无界队列，当生产者的生产能力大于消费者消费能力，那么队列中就可能堆积很多的产品，从而增加了资源消耗，为何限制生产者向队列中添加元素，引入了  
semaphore，semaphore可以控制同时put的数量，就像火车站进站口每次只放行几个人，从而控制了安检的流量，具体使用请看[例子](https://github.com/jasondong-1/java/blob/master/concurrent/src/main/java/com/jason/example/SemaphoreTest.java)

### 线程间直接输入与输出  
直接输入输出即不必借助中间方式，如文件，数据库等中间介质。这时要用到PipedInputstream 和 PipedOutPutStream；请看[例子](https://github.com/jasondong-1/java/blob/master/concurrent/src/main/java/com/jason/example/PipeInOut.java)  
>1.PipedInputstream 和 PipedOutPutStream适合在两个线程间使用，因为往往需要保证字节流的顺序性，如果线程过多还要维护字节顺序性，增加了程序复杂性  
2.异常问题，如果out线程抛出了异常，in线程可能永远等待下去，最好在catch块中关闭out来知会in线程  

### Thread interrupt  
线程a让线程b执行了一个耗时任务，但是b一直未执行结束，这是a要停止b线程，用什么法儿呢，interrupt；  
```
Thread.interrupt()
```
Thread 内部维护了一个中断标记，调用Thread.interrupt()会设置中断标记为true。  
加入a线程调用了b线程的interrupt() 方法，b线程会有什么相应？  
>1.b线程无相应，当线程正在执行 Inputstream.read 或 Lock.lock以及申请内部锁等阻塞方法时，就会出现这种状况  
2.b线程中断运行  

interrupt()方法是设置中断标记为true，那么下面两个方法是干啥的？  
```
    public static boolean interrupted() {
        return currentThread().isInterrupted(true);
    }

    public boolean isInterrupted() {
        return isInterrupted(false);
    }
```
>1.isInterrupted()方法用于查看当前线程的中断标记值  
2.interrupted()方法做两件事：  
 >>1）查看当前中断标记的值  
 2）将其设置为false  

按照惯例，凡是抛出InterrupeedException的方法，在其抛出InterrupeedException之前应该将中断标记设置为false，因此这种方法的一般写法为：  
```
public void func(){
  if(Thread.interrupted()){
    throw new InterrupeedException();
  }
  ...
}
```

interrupt()方法不仅可以设置线程的中断标志，还会唤醒线程，比方线程调用了 await，sleep()  

### 优雅停止线程

### 装饰器模式（Decorator） 同步集合   
我们可以将线程不安全的类（B）包装到一个新类（A）中，A提供了与B同签名的方法，但是是线程安全的。使用的时候我们直接使用A类即可。  
java中提供了如下的装饰器：  
```
        List<String> list = Collections.synchronizedList(new ArrayList<String>());
        Set<String> set = Collections.synchronizedSet(new HashSet<String>());
        .....
```

### 并发集合  
|非线程安全对象|并发集合|共同接口|遍历实现方式|
|---|---|---|---|
|ArrayList|CopyOnWriteArrayList|List|快照|
|HashSet|CopyOnWriteArraySet|Set|快照|
|LinkedList|ConcurrentLinkedQueue|Queue|准实时|
|HashMap|ConcurrentHashMap|Map|准实时|
|TreeMap|ConcurrentSkipListMap|SortedMap|准实时|
|TreeSet|ConcurrentSkipListSet|SortedSet|准实时|

Iterator 一次只能由一个线程来使用，多个线程最好不要共享Iterator  

与同步集合相比，并发集合对程序性能的提高更加显著，一般选择使用并发集合  

### 线程活性故障  
1..死锁  
```
 publice void a(){
   Lock a = ...
   lock b = ...
   a.lock
   tru{
    b.lock()
    try{
     .....
    }finally{
    b.release()
    }
   
   
   }finally{
   a.release()
   }
 
 }
 
  publice void b(){
    Lock a = ...
    lock b = ...
    b.lock
    tru{
     a.lock()
     try{
      .....
     }finally{
     a.release()
     }
    
    
    }finally{
    b.release()
    }
  
  }

```  
两个线程分别调用上述两个方法，各自持有一个锁，等待对方释放，就会造成死锁  
>解决方案：  
1.采用同意顺序申请锁：方法a() b() 都先申请 a lock 再申请 b lock  
2.使用更粗粒度的锁  
3.使用lock.trylock()方法  


2.锁死  
这个用白雪公主的例子比较好说  
```
Lock lock = new Reentrantlock()
Condition condition = lock.newCondition();

public void 公主醒来(){
lock.lock()
try{
 while(！（王子亲吻我）){
  condition.await()
 }
}finally{
 lock.unlock();
}

}

```
如果王子早就挂掉了，那么while循环就会一直循环下去，这种线程未终止，但一直处于未运行状态就是锁死。  


3.活锁  
线程一直处于运行状态，但是其任务毫无进展  







  
 
