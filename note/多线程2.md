### 正确的单例模式  
1. 单线程下的单利模式  
```java
/**
 * 单线程模式下的单利模式
 */
public class SingleThreadSingleton {
    private static SingleThreadSingleton instance;

    private SingleThreadSingleton() {
    }

    public static SingleThreadSingleton getInstance() {
        if (instance == null) {
            instance = new SingleThreadSingleton();
        }
        return instance;
    }
}
```

2.多线程下的单利模式  
2.1 正确的单利模式  
```java
/**
 * 这里演示的是一个线程安全的单例模式
 */
public class MultithreadingSingleton {
    private static MultithreadingSingleton instance = null;

    private MultithreadingSingleton() {

    }

    public static MultithreadingSingleton getInstance() {
        synchronized (MultithreadingSingleton.class) {
            if (instance == null) {
                instance = new MultithreadingSingleton();
            }
            return instance;
        }
    }

}
```
虽说上面的代码是线程安全的，但是没事获取实例的时候都要加锁，多少开销有点儿大，于是乎有了如下的版本2.2  

2.2不安全的单例模式  
```java
/**
 * 不安全
 */
class MultithreadingSingletonV2 {
    private static MultithreadingSingletonV2 instance = null;

    private MultithreadingSingletonV2() {

    }

    public static MultithreadingSingletonV2 getInstance() {
        if (instance == null) {  //1.
            synchronized (MultithreadingSingleton.class) {
                if (instance == null) {//2.
                    instance = new MultithreadingSingletonV2();
                }
            }
        }
        return instance;

    }

}
```  
我们之前说过，锁保证线程安全的前提是，不管读还是写共享变量都要加锁， 而操作1在读取共享变量缺没有加锁，所以会造成线程安全问题  
原因如下：  
instance = new MultithreadingSingletonV2();可以分解为如下三个步骤：  
1.给MultithreadingSingletonV2() 分配存储空间  
2.初始化MultithreadingSingletonV2()  
3.将MultithreadingSingletonV2()的对象地址赋值给instance    

但是编译后可能发生如下重排序：1 - 3 - 2  

所以当步骤1 读到instance不为null时，MultithreadingSingletonV2() 可能并未初始化完毕  
解决办法：给instance 变量加volatile 修饰，防止instance = new MultithreadingSingletonV2() 重排序  

### CAS  
compare and swap 比较再进行赋值，请看伪代码：  
```
public boolean cas（int oldval ,int newval, Object var）{//var 是共享变量  
 if(var.get==oldvar){
   var.set(newval)
   return true
 }
 return false
}
```
一般情况下cas与循环一起使用来更新值：  
```
int oldval;
int newval;
do{
 oldval = var.get
 newval = oldval+1
}while(!cas(oldval,newval,var))
```

cas 操作只能保障更新操作的原子性,不保障可见性  

### 原子变量类  
AtomicLong AtomicInteger 等，实现原理 cas + volatile  
**提供使用sample**  

### static 和 final 在多线程中的应用  
|  | static | final |
| --- | --- | --- |
| 有序性 | 保障 | 保障 |
| 可见性 | 保障 | 不保障 |  
static：第一次读取到变量时可以保障可见性   

 
### 多线程可以提高多少速率  
$$ S_{max}=\frac{1}{p+\frac{1-p}{N}} $$ 
其中p是必须同步的处理流程所消耗的时间比例，N是并发数，可以看到当核数趋于无穷大的时候，多线程的速率其实和必须同步的  
时间有关，所以得优化算法来把串行事件缩短  

### 多线程设置多少个并发数  
1.cpu密集型：设置N+1 个，因为cpu密集型任务可能由于缺页中断而被切出等问题，为避免cpu浪费，多设置一个  
2.io密集型：可能导致上下文切换，如果一个线程可以满足性能要求则设置一个即可，如果一个不能满足需求，则设置  
2N个，因为io密集型任务在等待返回时是不占用cpu资源的  

3.在实际的开发当中，当前任务可能是cpu密集+io密集型的，那么我们课程采用如下公式计算  
$$ N_{thread} = N_{cpu} * U_{cpu} * (1+\frac{WT}{ST})$$  

其中 N<sub>thread</sub> 代表最终设置的线程数  
N<sub>cpu</sub>代表机器的核数  
U<sub>cpu</sub> 表示当前进程战友的资源比例（人为规定的）  
WT代表程序的等待时间（我理解未等待io返回等不占用cpu的时间）  
ST service time 占用cpu的时间  
wt st 可以用我们之前介绍的jvisualvm工具来查看  

### wait/notify  
在多线程中，一个线程执行目标操作前需要满足一定条件就需要用到wait/notify  
[请看例子]() 

 
